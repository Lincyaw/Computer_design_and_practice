.data

.text
############   FBI WARNING: !!!!!!!
############   FBI WARNING: !!!!!!!
############   FBI WARNING: !!!!!!!
############        测试方法: sw23是模式1,sw22是模式2,sw21是模式3
############                 sw0123是模式3的输入,可选0~15个LED灯亮,然后进行循环右移
############        代码思路:
############                 模式1和模式2前有伪代码注释
############                 大概思路为 用$2表示高8位灯的状态,用$2表示低16位灯的状态
############                           令$1寄存器中的高4位一直等于$2寄存器中的低4位,实现串联
############                           这样就可以将$2和$1合并起来看成对24个LED灯处理的大寄存器
############                           模式3中则再令$1寄存器中的高4位一直等于$2寄存器中的低4位
############                           这样就实现了一个环,本来是一条线,现在把线的两端也连起来了,就可以循环移位
prepare:
    #C72: 高8位拨码
    #C70: 低16位拨码
    #C62: 高8位LED
    #C60: 低16位LED

    #读入高8位拨码,模式选择
    lui   $5,0xFFFF          
    ori   $28,$5,0xF000   #$28=0xFFFFF???,作为偏移
    lw   $5,0xC72($28)
    andi $6,$5,0x0080
    andi $7,$5,0x0040
    andi $8,$5,0x0020
    andi $1,$1,0x0
    bne $6,$0,mode1   #按了sw23
    bne $7,$0,mode2   #按了sw22
    bne $8,$0,mode3   #按了sw21 


    j prepare

mode1:
    #模式1
    #令$1作为低16个灯的状态
    #令$2作为高12个灯的状态
    #因为一次只能写16个LED灯,所以24个灯要分成两次
    #$1以$C60作为起始位置进行写操作,高4位的灯取$2的低4位的灯的状态
    #这样就利用$2的第四位作为一个承接,使$2与$1的灯串联了起来

    #伪代码
    # if(灯全灭)
    #     $1=00000000 00000000 00000000 00000001 
    #     $2=00000000 00000000 10000000 00000000
    #     disp $1 and $2
    # while(灯没全亮)//全亮的判断条件即为$1的第11位和$2的第4位为1
    #     $10=$1<<1 
    #     $1=$10|$1
    #     $10=$2>>1
    #     $2=$10|$2

    #     #令$1的12~15位等于$2的0~3位
    #     $11=00000000 00000000 00001111 11111111
    #     $11=$11&$1
    #     $12=00000000 00000000 00000000 00001111
    #     $12=$12&$2
    #     $12=$12<<12
    #     $1=$12|$11

    #     $3=$2>>4
    #     disp $1 and $3
        
    # if(灯全亮)
    #     $1=00000000 00000000 00000111 11111111 
    #     $2=00000000 00000000 00001111 11111110
    #     #令$1的12~15位等于$2的0~3位
    #     $11=00000000 00000000 00001111 11111111
    #     $11=$11&$1
    #     $12=00000000 00000000 00000000 00001111
    #     $12=$12&$2
    #     $12=$12<<12
    #     $1=$12|$11

    #     $3=$2>>4
    #     disp $1 and $3
    # while(灯没全灭)//全灭的判断条件即为$1的第0位和$2的第15位为0,$2的高16位的状态不影响LED的输出
    #     $1=$1>>1 
    #     $2=$2<<1

    #     #令$1的12~15位等于$2的0~3位
    #     $11=00000000 00000000 00001111 11111111
    #     $11=$11&$1
    #     $12=00000000 00000000 00000000 00001111
    #     $12=$12&$2
    #     $12=$12<<12
    #     $1=$12|$11

    #     $3=$2>>4
    #     disp $1 and $3
LightsAllOff:
    andi $1,$1,0x0
    ori $1,$1,0x1
    andi $2,$2,0x0
    ori $2,$2,0x0800

    srl $3,$2,4
    sw $1, 0xC60($28)  #亮一次,不用检查$1和$2,因为此时都是灭的
    sw $3, 0xC62($28) 
    jal DelayHalfSeconds
TurnOn:
#$10,$11,$12为段内变量
    sll $10,$1,0x1
    or $1,$1,$10
    srl $10,$2,0x1
    or $2,$2,$10

    andi $11,$11,0x0
    ori $11,$11,0x0FFF
    and $11,$11,$1

    andi $12,$12,0x0
    ori $12,$12,0x000F
    and $12,$2,$12
    sll $12,$12,0xC #向左移12位
    or $1,$12,$11

    srl $3,$2,4
    sw $3, 0xC62($28) 
    sw $1, 0xC60($28) 
    
    jal DelayHalfSeconds

    andi $11,$11,0x0800
    and $11,$1,$11 #取$1的第11位,该位亮了就表示全亮了
    bne $11,$0,LightAllOn #因为$2与$1是对称的,所以判断一个即可
    j TurnOn
LightAllOn:
    andi $1,$1,0x0
    ori $1,$1,0x07FF
    andi $2,$2,0x0
    ori $2,$2,0x0FFE

    andi $11,$11,0x0
    ori $11,$11,0x0FFF
    and $11,$11,$1

    andi $12,$12,0x0
    ori $12,$12,0x000F
    and $12,$2,$12
    sll $12,$12,0xC #向左移12位
    or $1,$12,$11

    srl $3,$2,4

    sw $3, 0xC62($28) 
    sw $1, 0xC60($28) 

   jal DelayHalfSeconds
TurnOff:
    srl $1,$1,0x1
    sll $2,$2,0x1

    andi $11,$11,0x0
    ori $11,$11,0x0FFF
    and $11,$11,$1

    andi $12,$12,0x0
    ori $12,$12,0x000F
    and $12,$2,$12
    sll $12,$12,0xC #向左移12位
    or $1,$12,$11


    srl $3,$2,4

    sw $3, 0xC62($28) 
    sw $1, 0xC60($28) 

    jal DelayHalfSeconds
    andi $11,$11,0x0001
    and $11,$1,$11 #取$1的第0位,该位灭了就表示全灭了
    beq $11,$0,prepare
    j TurnOff



mode2:
    # if(灯全灭)
    # $1=00000000 00000000 00000000 00000000 
    # $2=00000000 00000000 10000000 00000000
    # disp $1 and $2

    # while(灯没全亮)//全亮的判断条件即为$1的第11位和$2的第4位为1
    # $10=$1>>1 
    # $1=$10|$1
    # $10=$2>>1
    # $2=$10|$2

    # #令$1的12~15位等于$2的0~3位
    # $11=00000000 00000000 00001111 11111111
    # $11=$11&$1
    # $12=00000000 00000000 00000000 00001111
    # $12=$12&$2
    # $12=$12<<12
    # $1=$12|$11

    # $3=$2>>4
    # disp $1 and $3
    
    # if(灯全亮)

    # while(灯没全灭)//全灭的判断条件即为$2的第15位为0
    #     $1=$1>>1 
    #     $2=$2>>1

    #     #令$1的12~15位等于$2的0~3位
    #     $11=00000000 00000000 00001111 11111111
    #     $11=$11&$1
    #     $12=00000000 00000000 00000000 00001111
    #     $12=$12&$2
    #     $12=$12<<12
    #     $1=$12|$11

    #     $3=$2>>4
    #     disp $1 and $3
LightsAllOff1:
    andi $1,$1,0x0
    ori $1,$1,0x0
    andi $2,$2,0x0
    ori $2,$2,0x0800

    srl $3,$2,4
    sw $1, 0xC60($28)  #亮一次,不用检查$1和$2,因为此时都是灭的
    sw $3, 0xC62($28) 
    jal DelayHalfSeconds
TurnOn1:
#$10,$11,$12为段内变量
    srl $10,$1,0x1
    or $1,$1,$10
    srl $10,$2,0x1
    or $2,$2,$10

    andi $11,$11,0x0
    ori $11,$11,0x0FFF
    and $11,$11,$1

    andi $12,$12,0x0
    ori $12,$12,0x000F
    and $12,$2,$12
    sll $12,$12,0xC #向左移12位
    or $1,$12,$11

    srl $3,$2,4
    sw $3, 0xC62($28) 
    sw $1, 0xC60($28) 
    
    jal DelayHalfSeconds

    andi $11,$11,0x0001
    and $11,$1,$11 #取$1的第0位,该位亮了就表示全亮了
    bne $11,$0,LightAllOn1 
    j TurnOn1


LightAllOn1:
TurnOff1:
    srl $1,$1,0x1
    srl $2,$2,0x1

    andi $11,$11,0x0
    ori $11,$11,0x0FFF
    and $11,$11,$1

    andi $12,$12,0x0
    ori $12,$12,0x000F
    and $12,$2,$12
    sll $12,$12,0xC #向左移12位
    or $1,$12,$11
    srl $3,$2,4

    sw $3, 0xC62($28) 
    sw $1, 0xC60($28) 

    jal DelayHalfSeconds
    andi $11,$11,0x0001
    and $11,$1,$11 #取$1的第0位,该位灭了就表示全灭了
    beq $11,$0,prepare
    j TurnOff1



mode3:
    lui   $5,0xFFFF          
    ori   $28,$5,0xF000   #$28=0xFFFFF???,作为偏移
    lw   $5,0xC70($28)
    andi $1,$5,0x000F
    andi $2,$2,0x0
    
    andi $9,$9,0x0  #极为憨批的手动译码,0~F
    ori $9,$9,0x0
    beq $1,$9,num0

    andi $9,$9,0x0
    ori $9,$9,0x1
    beq $1,$9,num1

    andi $9,$9,0x0
    ori $9,$9,0x2
    beq $1,$9,num2

    andi $9,$9,0x0
    ori $9,$9,0x3
    beq $1,$9,num3

    andi $9,$9,0x0
    ori $9,$9,0x4
    beq $1,$9,num4

    andi $9,$9,0x0
    ori $9,$9,0x5
    beq $1,$9,num5

    andi $9,$9,0x0
    ori $9,$9,0x6
    beq $1,$9,num6

    andi $9,$9,0x0
    ori $9,$9,0x7
    beq $1,$9,num7

    andi $9,$9,0x0
    ori $9,$9,0x8
    beq $1,$9,num8

    andi $9,$9,0x0
    ori $9,$9,0x9
    beq $1,$9,num9

    andi $9,$9,0x0
    ori $9,$9,0xA
    beq $1,$9,num10

    andi $9,$9,0x0
    ori $9,$9,0xB
    beq $1,$9,num11

    andi $9,$9,0x0
    ori $9,$9,0xC
    beq $1,$9,num12

    andi $9,$9,0x0
    ori $9,$9,0xD
    beq $1,$9,num13

    andi $9,$9,0x0
    ori $9,$9,0xE
    beq $1,$9,num14

    andi $9,$9,0x0
    ori $9,$9,0xF
    beq $1,$9,num15

num0:
    andi $1,$1,0x0
    j assign
num1:
    andi $1,$1,0x0
    ori $1,$1,0x1
    j assign
num2:
    andi $1,$1,0x0
    ori $1,$1,0x3
    j assign
num3:
    andi $1,$1,0x0
    ori $1,$1,0x7
    j assign
num4:
    andi $1,$1,0x0
    ori $1,$1,0xF
    j assign
num5:
    andi $1,$1,0x0
    ori $1,$1,0x1F
    j assign
num6:
    andi $1,$1,0x0
    ori $1,$1,0x3F
    j assign
num7:
    andi $1,$1,0x0
    ori $1,$1,0x7F
    j assign
num8:
    andi $1,$1,0x0
    ori $1,$1,0xFF
    j assign
num9:
    andi $1,$1,0x0
    ori $1,$1,0x1FF
    j assign
num10:
    andi $1,$1,0x0
    ori $1,$1,0x3FF
    j assign
num11:
    andi $1,$1,0x0
    ori $1,$1,0x7FF
    j assign
num12:
    andi $1,$1,0x0
    ori $1,$1,0xFFF
    j assign
num13:
    andi $1,$1,0x0
    ori $1,$1,0x1FFF
    ori $2,$2,0x1
    sll $2,$2,0x1
    j assign
num14:
    andi $1,$1,0x0
    ori $1,$1,0x3FFF
    ori $2,$2,0x3
    sll $2,$2,0x1
    j assign
num15:
    andi $1,$1,0x0
    ori $1,$1,0x7FFF
    ori $2,$2,0x7
    sll $2,$2,0x1
assign:
    sll $1,$1,1
    andi $4,$4,0x0
    or $4,$4,$1  #备份$1
ShowLed:
    srl $1,$1,0x1
    srl $2,$2,0x1

    andi $11,$11,0x0  #下面两段把$2低4位给$1高4位
    ori $11,$11,0x0FFF
    and $11,$11,$1

    andi $12,$12,0x0
    ori $12,$12,0x000F
    and $12,$2,$12
    sll $12,$12,0xC #向左移12位
    or $1,$12,$11

    andi $11,$11,0x0  #下面两段把$1低4位给$2高4位
    ori $11,$11,0x000F
    and $11,$11,$1
    sll $11,$11,0xC

    andi $12,$12,0x0
    ori $12,$12,0x0FFF
    and $12,$2,$12
    or $2,$11,$12


    srl $3,$2,4
    sw $3, 0xC62($28) 
    sw $1, 0xC60($28) 
    jal DelayHalfSeconds

    andi $9,$9,0x0
    ori $9,$9,0xffff
    and $9,$1,$9
    bne $9,$4,ShowLed  #不一样的话就循环,一样说明跑了一次了
    j prepare
DelayHalfSeconds:
    andi $13,$13,0x0 #128,选用256Hz的主频,半秒
    ori  $13,$13,0x0080
    andi $14,$14,0x0
Delay:
    addi	$14,$14,0x1	
    bne $13,$14,Delay
    jr $31